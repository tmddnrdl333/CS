

# DB

## 1. Key

Key 란? : 검색, 정렬 시 Tuple을 구분할 수 있는 기준이 되는 Attribute



### (1) 후보키 - Candidate Key

- 릴레이션 구성 속성들 중 튜플을 **유일하게 식별할 수 있는 속성들의 부분집합**
- **모든 릴레이션은 반드시 하나 이상의 후보키를 가져야**한다.
- **유일성과 최소성을 만족**

= 기본키가 될 수 있는 키들

ex) 학생의 학번과 주민번호



### (2) 기본키 - Primary Key

- 후보키 중 주키
- 특정 튜플을 **유일하게 구별**할 수 있는 속성
- **Null값을 가질 수 없다.**
- **동일 값을 중복 저장할 수 없다**.

ex) 학번을 기본키로 할 수 있음.

+) 기본키가 여러 컬럼으로 구성됐다면 복합키라고 부름.



### (3) 대체키 - Alternate Key

- 후보키가 둘 이상일 때 기본키 제외한 나머지 후보키들

ex) 학번이 기본키면 주민번호는 대체키가 됨



### (4) 슈퍼키 - Super Key

- 한 릴레이션 내 속성들의 집합으로 구성된 키

- **유일성은 만족하지만 최소성은 만족하지 못함.**

ex) 슈퍼키는 '학번', '주민번호', '학번'+'주민번호', '학번'+'주민번호'+'성명' 등으로 구성할 수 있음.

'학번'+'주민번호'+'성명'을 슈퍼키로 사용했을 경우 3개의 속성 조합을 통해 다른 튜플들과 구별이 가능해지지만, '성명' 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못함. 즉, 뭉쳤을 경우에 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성있는 키로 사용되지 못하는 경우 최소성을 만족하지 못한다고 함.



### (5) 외래키 - Foreign Key

- 관계를 맺고 있는 릴레이션 R1, R2에서, R1이 참조하고 있는 R2의 기본키와 같은 R1의 속성
- 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간 참조 관계를 표현하는데 중요한 도구로 사용됨.
- 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없게 됨. (참조 무결성 조건)

각 릴레이션 입장에서 속성은 기본키가 되기도, 외래키가 되기도 함.



![009](../_img/009.png)





## 2. SQL - JOIN

### (1) 조인이란?

- 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법

### (2) 조인의 종류

- inner join

![001](../_img/001.png)

- left outer join

![002](../_img/002.png)

- right outer join

![003](../_img/003.png)

- full outer join

![004](../_img/004.png)

- cross join

![005](../_img/005.png)

- self join

![006](../_img/006.png)





## 3. SQL - Injection

- 해커에 의해 조작된 SQL 쿼리문이 DB에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법

### (1) 공격 방법

1. 인증 우회

   - 보통 로그인시, id pw를 input창에 입력하게 된다.

   > SELECT * FROM USER WHERE ID="abc" AND PASSWORD="1234";

   - 이 때, id에 쿼리문을 입력해서 악용할 수 있다.

   id에 `1' or '1'='1`를 입력하면...

   > ~ ID = '1' or '1'='1' ~

   가 되면서 항상 True인 구문이 되어버린다. 즉, WHERE 구문이 우회된 채로 SQL 쿼리문이 실행되기 때문에 DB내 모든 사용자 정보가 노출된다.



2. 데이터 노출
   - 시스템에서 발생하는 에러 메시지는, 보통 개발자가 버그를 수정할 때 도움을 받을 수 있게 해준다. 하지만 해커들은 이를 역이용해 악의적인 구문을 삽입하여 에러를 유발시킨다.
   - 예를 들면, GET방식으로 동작하는 URL의 쿼리 스트링을 조작하여 에러를 발생시킨다. 이에 해당하는 오류가 발생하면, 이를 통해 해당 웹앱의 데이터베이스 구조를 유추할 수 있고, 해킹에 활용하게 된다.



### (2) 방어 방법

1. input 값을 받을 때, 특수문자 여부 검사하기
   - 검증 로직을 추가하여 미리 설정한 특수문자들이 들어왔을 때 요청을 막아낸다.
2. SQL 서버 오류 발생 시, 해당하는 에러 메시지 감추기
   - view를 활용하여 원본 DB 테이블에는 접근 권한을 높힌다. 일반 사용자는 view로만 접근하여 에러를 볼 수 없도록 만든다.
3. preparestatement 사용하기
   - preparestatement를 사용하면, 특수문자를 자동으로 escaping 해준다.
   - `PreparedStatement pstmt = conn.prepareStatement(sql)`



## 4. SQL vs NoSQL

MySQL과 같은 SQL을 사용할까, 아니면 MongoDB와 같은 NoSQL을 사용할까?

보통 Spring에서 개발할 때 MySQL을, Node.js에서는 MongoDB를 주로 사용한다.

하지만 단순히 프레임워크에 따라 결정하는 게 아니라, 적합한 데이터베이스를 택해야 한다.



### (1) SQL - 관계형 DB

SQL을 사용하면, RDBMS(관계형 데이터데이스 관리 시스템)

관계형 데이터베이스의 핵심적인 두 특징은

1. 데이터는 **정해진 데이터 스키마에 따라 테이블에 저장**된다.
2. 데이터는 **관계를 통해 여러 테이블에 분산**된다.

즉, 스키마(테이블마다 명확히 정의된 구조)를 준수하지 않은 레코드는 테이블에 추가할 수 없다.

또한, 데이터의 중복을 피하기 위해 '관계'를 이용한다.



### (2) NoSQL - 비관계형 DB

말 그대로 반대이다.

**스키마도 없고, 관계도 없다.**

NoSQL에서는 레코드를 문서라고 부른다. (문서는 보통 Json 형태로 저장됨)

서로 다른 구조의 데이터를 같은 컬렉션에 추가할 수 있다. 따라서 여러 테이블에 조인할 필요 없이 이미 여러 테이블이 한 문서에 있는 것이 NoSQL이다. (Join 개념이 존재하지 않음)

따라서, 조인을 잘 사용하지 않고, 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.



### (3) 확장 개념

데이터베이스 서버 확장성은 '수직적'/'수평적' 확장으로 나뉨

- 수직적 확장 : 단순히 DB서버 성능의 향상 (ex. CPU 업그레이드)
- 수평적 확장 : 더 많은 서버가 추가되고 DB가 전체적으로 분산됨을 의미 (하나의 DB에서 작동하지만 여러 호스트에서 작동)

하지만 데이터 저장 방식으로 인해 SQL DB는 일반적으로 수직적 확장만 지원함.



### (4) 장단점

SQL 장점

- 명확하게 정의된 스키마, 데이터 무결성 보장.
- 관계는 각 데이터를 중복없이 한 번만 저장.

SQL 단점

- 덜 유연. 데이터 스키마를 사전에 계획하고 알아야 함. (추후 수정 어려움)
- join문이 많은 복잡한 쿼리가 만들어질 수 있음.
- 대체로 수직적 확장만 가능.

NoSQL 장점

- 유연함. 언제든 데이터 조정과 새 필드 추가 가능.
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빠름.
- 수직/수평적 확장이 가능해서 모든 읽기/쓰기 요청 처리 가능

NoSQL 단점

- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음.
- 데이터 중복을 계속 업데이트해야 함
- 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정 시 모든 컬렉션에서 수행해야 함.



### (5) 선택

SQL

- 관계를 맺고 있는 데이터가 자주 변경될 때,

- 변경될 여지가 없는 명확한 스키마가 사용자와 데이터에게 중요할 때.

NoSQL

- 정확한 데이터 구조를 알 수 없거나, 변경/확장 될 수 있을 때,
- 읽기는 자주 하지만, 변경은 자주 없을 때,
- DB를 수평적으로 확장해야 할 때 (막대한 양의 데이터를 다뤄야 할 때)



하지만 SQL을 선택해서 복잡한 JOIN문을 만들지 않도록 설계하여 단점을 보완할 수도,

NoSQL을 선택해서 중복 데이터를 줄이는 방법으로 설계해서 단점을 보완할 수도 있다.



<hr/>



## 5. 정규화

정규화의 목표  :

- 데이터 중복을 없에고 불필요한 데이터 최소화시킨다. 
- 무결성을 지키고, 이상 현상 방지한다.
- 테이블 구성을 논리적이고 직관적이게 한다.
- DB구조 확장이 용이해진다.



### (1) 제 1정규화 - 1NF

> 정규화 : Normalization, 정규형 : Normal Form (NF)

테이블 컬럼이 **원자값(하나의 값)을 갖도록** 테이블을 분리시키는 것.

조건 :

- 어떤 릴레이션에 속한 모든 도메인이 원자값만으로 되어 있어야 한다.
- 모든 속성에 반복되는 그룹이 나타나지 않는다.
- 기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다.



![007](../_img/007.png)

전화번호가 여러개 있어서 원자값이 아님. 따라서 아래와 같이 분리.

![008](../_img/008.png)



### (2) 제 2정규화 - 2NF

테이블 모든 컬럼이 **완전 함수 종속**을 만족해야 한다.

> = 기본키의 부분집합 키가 결정자가 되어선 안된다.
>
> = 기본키가 복합키로 묶여있을 때, 두 키 중 하나의 키만으로 다른 컬럼을 결정할 수 있으면 안된다.



![010](../_img/010.png) 

Manufacturer 과 Model 이 키가 되어 Model Full Name을 알 수 있다.

근데 Manufacturer 만으로 Manufacturer Country를 결정할 수 있다. (부분 함수 종속)

> 기본키만으로 모든 컬럼을 결정하면 "완전 함수 종속" (결정자와 종속자)
>
> 위와 같은 경우는 "부분 함수 종속"
>
> X->Y 이고 Y->Z일 때 Y->X가 아니라면 X->Z이다. "이행적 종속"

따라서 Model은 Manufacturer Country와 연관이 없기 때문에, 부분 함수 종속인 부분을 떼어내서 완전 함수 종속인 두 테이블로 만들 수 있다.

![011](../_img/011.png)



### (3) 제 3정규화 - 3NF

2NF가 진행된 테이블에서 **이행적 종속을 없에기 위해** 테이블을 분리하는 것

 조건 :

- 릴레이션이 2NF에 만족한다.
- 기본키가 아닌 속성들은 기본키에 의존한다.

![012](../_img/012.png)

Tournament 와 Year 이 기본키(복합키)

Winner는 이 복합키를 통해 결정.

하지만 Winner Date of Birth는 복합키가 아닌 Winner에 의해 결정. (이행적 종속)

따라서 3NF를 위반하므로, 분리해야 한다.

![013](../_img/013.png)
